{"componentChunkName":"component---src-templates-post-template-js","path":"/posts/bioinformatics-pipeline-with-nextflow","result":{"data":{"markdownRemark":{"id":"fba83005-5c30-5d5a-8162-a1f4f58363cd","html":"<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 960px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/7ac17c4f63611789bd96206229d988b0/eea4a/pipeline.jpg\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 75%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAPABQDASIAAhEBAxEB/8QAFwAAAwEAAAAAAAAAAAAAAAAAAAEDAv/EABUBAQEAAAAAAAAAAAAAAAAAAAIB/9oADAMBAAIQAxAAAAGG4VLYiL//xAAZEAACAwEAAAAAAAAAAAAAAAABAgARMRL/2gAIAQEAAQUCWGuW0QC0O//EABURAQEAAAAAAAAAAAAAAAAAAAAR/9oACAEDAQE/AVf/xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAECAQE/AT//xAAZEAACAwEAAAAAAAAAAAAAAAABEAARIUH/2gAIAQEABj8C7AdVP//EABsQAQACAgMAAAAAAAAAAAAAAAEAIRFBMVHB/9oACAEBAAE/ITh8Skt2UYOILw5jAGnuN0n/2gAMAwEAAgADAAAAEIgP/8QAFxEBAQEBAAAAAAAAAAAAAAAAAQARMf/aAAgBAwEBPxAcg52//8QAFhEBAQEAAAAAAAAAAAAAAAAAABEB/9oACAECAQE/EImv/8QAGxABAAMAAwEAAAAAAAAAAAAAAQARITFBYXH/2gAIAQEAAT8QBFwJ931Et0i6Lx72LIQ8VEtYB1PIMpso0rZetd032f/Z'); background-size: cover; display: block;\"\n  ></span>\n  <picture>\n          <source\n              srcset=\"/static/7ac17c4f63611789bd96206229d988b0/8ac56/pipeline.webp 240w,\n/static/7ac17c4f63611789bd96206229d988b0/d3be9/pipeline.webp 480w,\n/static/7ac17c4f63611789bd96206229d988b0/e46b2/pipeline.webp 960w,\n/static/7ac17c4f63611789bd96206229d988b0/af3f0/pipeline.webp 1280w\"\n              sizes=\"(max-width: 960px) 100vw, 960px\"\n              type=\"image/webp\"\n            />\n          <source\n            srcset=\"/static/7ac17c4f63611789bd96206229d988b0/09b79/pipeline.jpg 240w,\n/static/7ac17c4f63611789bd96206229d988b0/7cc5e/pipeline.jpg 480w,\n/static/7ac17c4f63611789bd96206229d988b0/6a068/pipeline.jpg 960w,\n/static/7ac17c4f63611789bd96206229d988b0/eea4a/pipeline.jpg 1280w\"\n            sizes=\"(max-width: 960px) 100vw, 960px\"\n            type=\"image/jpeg\"\n          />\n          <img\n            class=\"gatsby-resp-image-image\"\n            src=\"/static/7ac17c4f63611789bd96206229d988b0/6a068/pipeline.jpg\"\n            alt=\"Create your bioinformatics pipeline\"\n            title=\"Create your bioinformatics pipeline\"\n            loading=\"lazy\"\n            style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n          />\n        </picture>\n  </a>\n    </span></p>\n<p>Now that you know how to run bioinformatics software in Docker containers, it’s time to connect them up. If you’ve missed the last post the link is here: <a href=\"/posts/getting-started-with-docker-for-bioinformatics\">Getting started with Docker for bioinformatics.</a></p>\n<h2 id=\"content-overview\" style=\"position:relative;\"><a href=\"#content-overview\" aria-label=\"content overview permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Content Overview</h2>\n<ol>\n<li>What is a pipeline?</li>\n<li>Nextflow vs Snakemake</li>\n<li>Using Nextflow and Docker containers to create your pipeline</li>\n<li>Summary</li>\n</ol>\n<h2 id=\"what-is-a-pipeline-anyway\" style=\"position:relative;\"><a href=\"#what-is-a-pipeline-anyway\" aria-label=\"what is a pipeline anyway permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>What is a pipeline anyway?</h2>\n<p>The term ‘pipeline’ is thrown around a lot in bioinformatics. In simple terms, it refers to the programs that have to be run in a certain order to complete the analysis. Some of these programs take the outputs of earlier programs and process them in order to achieve a specific objective.</p>\n<p>This can be as simple as a couple of programs or it can become a messy spider web. A basic example would be: raw fastq files from the sequencer —> passing it through an aligner against the human genome —> variant calling.</p>\n<p>NF core have a nice set of pipelines <a href=\"https://nf-co.re/pipelines\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">here</a> including much more complex ones.</p>\n<h2 id=\"how-to-get-started\" style=\"position:relative;\"><a href=\"#how-to-get-started\" aria-label=\"how to get started permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>How to get started</h2>\n<p>There are two key frameworks that I will point you to: <a href=\"https://www.nextflow.io/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">nextflow</a> and <a href=\"https://snakemake.readthedocs.io/en/stable/%5D\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">snakemake</a>. These are the programs that will run your programs for you and orchestrate the input and output files.</p>\n<h2 id=\"nextflow-vs-snakemake\" style=\"position:relative;\"><a href=\"#nextflow-vs-snakemake\" aria-label=\"nextflow vs snakemake permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Nextflow vs Snakemake</h2>\n<p>Disclaimer: this is my personal opinion on this topic. Try both and make up your mind as to which suits your thought process better.</p>\n<h3 id=\"1-the-programming-language-difference-doesnt-matter\" style=\"position:relative;\"><a href=\"#1-the-programming-language-difference-doesnt-matter\" aria-label=\"1 the programming language difference doesnt matter permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1. The programming language difference doesn’t matter.</h3>\n<p>Snakemake is based on python whereas nextflow uses groovy (which is like python for java). Initially when I first came across these comparisons I immediately jumped to snakemake as I’m pretty comfortable with python.</p>\n<p>Having tried both now, I would say that since you need to learn the pipeline syntax anyway, the actual difference between python and groovy is pretty minimal.</p>\n<h3 id=\"2-the-biggest-difference-is-the-thinking-direction-of-the-pipeline\" style=\"position:relative;\"><a href=\"#2-the-biggest-difference-is-the-thinking-direction-of-the-pipeline\" aria-label=\"2 the biggest difference is the thinking direction of the pipeline permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2. The biggest difference is the ‘thinking direction’ of the pipeline</h3>\n<p>Let me explain what I mean. In snakemake you have to ‘think backwards’ and work your way from the desired output towards the input. I find nextflow way more intuitive in that you think about your pipeline in sequence of how you run your programs.</p>\n<p><strong>Here’s how you have to think in snakemake:</strong> I need output C which comes from program B and to get program B to run you need the output of program A.</p>\n<p><strong>Compared to nextflow:</strong> With my input files I run it in program A and then take it to program B. Output C will result.</p>\n<h3 id=\"3-why-i-switched-to-nextflow-the-separation-of-how-the-pipeline-is-run-from-what-the-pipeline-is\" style=\"position:relative;\"><a href=\"#3-why-i-switched-to-nextflow-the-separation-of-how-the-pipeline-is-run-from-what-the-pipeline-is\" aria-label=\"3 why i switched to nextflow the separation of how the pipeline is run from what the pipeline is permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3. Why I switched to Nextflow: The separation of how the pipeline is run from what the pipeline is</h3>\n<p>The key reason why I switched from snakemake to nextflow is ‘the decoupling of pipeline execution’ or in plain terms, the separation of where and how your pipeline is run and what the pipeline actually does. The series of steps is described in the main file while the execution can be controlled by the configuration. We will cover pipeline execution in a separate article.</p>\n<h2 id=\"nextflow-pipeline\" style=\"position:relative;\"><a href=\"#nextflow-pipeline\" aria-label=\"nextflow pipeline permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Nextflow Pipeline</h2>\n<p>It is now time to go into more detail on setting up your pipeline in nextflow. Here’s an example pipeline which takes in Illumina paired reads, runs them through fastqc and bowtie2 and perform some simple statistics on the aligned file.</p>\n<h3 id=\"prerequisites\" style=\"position:relative;\"><a href=\"#prerequisites\" aria-label=\"prerequisites permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Prerequisites</h3>\n<ol>\n<li>Install Nextflow</li>\n<li>Install Docker</li>\n</ol>\n<h3 id=\"1-set-up-and-define-your-input-and-outputs\" style=\"position:relative;\"><a href=\"#1-set-up-and-define-your-input-and-outputs\" aria-label=\"1 set up and define your input and outputs permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1. Set up and define your input and outputs</h3>\n<p>First we set up a couple of parameters that can be easily changed depending on whether you are running test files vs actual data. These parameters can be modified in your config profiles.</p>\n<div class=\"gatsby-highlight\" data-language=\"sh\"><pre class=\"language-sh\"><code class=\"language-sh\">// main.nf file\n#!/usr/bin/env nextflow\n\n// PIPELINE PARAMETERS HERE\n\n// Input Files\nparams.reads = &quot;$baseDir/data/*/*_{R1,R2}_*.fastq.gz&quot;\n\n// Report Directory\nparams.outdir = &#39;reports&#39;\n\n// Reference Genomes\nparams.bowtie2_reference_index = &quot;$baseDir/reference_db/bowtie2/bt2_index.tar.gz&quot;\nbowtie2_db_ch = Channel.value(file(&quot;${params.bowtie2_reference_index}&quot;))</code></pre></div>\n<h3 id=\"2-create-channels-and-feed-your-input-into-them\" style=\"position:relative;\"><a href=\"#2-create-channels-and-feed-your-input-into-them\" aria-label=\"2 create channels and feed your input into them permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2. Create ‘channels’ and feed your input into them</h3>\n<p>In nextflow, there is this concept of ‘channels’. The basic premise is simple - each channel represents one file that can only be consumed once (unless it’s a ‘value channel’). Think of channels as pipes that you can feed files into which can be used only once.</p>\n<p>In this example, we generate the channels using the fromFilePairs method and create 2 channels - <code class=\"language-text\">fastqc_reads</code> and <code class=\"language-text\">reads_for_alignment</code>. *side note this is using the standard nextflow language rather than their newer DSL2.</p>\n<div class=\"gatsby-highlight\" data-language=\"sh\"><pre class=\"language-sh\"><code class=\"language-sh\">reads = Channel.fromFilePairs(params.reads)\nreads.into { fastqc_reads; reads_for_alignment }</code></pre></div>\n<h3 id=\"3-now-lets-have-a-look-at-our-first-process-and-break-it-down\" style=\"position:relative;\"><a href=\"#3-now-lets-have-a-look-at-our-first-process-and-break-it-down\" aria-label=\"3 now lets have a look at our first process and break it down permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3. Now let’s have a look at our first process and break it down</h3>\n<p>Here is the process block - this process is named <code class=\"language-text\">fastqc_run</code> but you can change this to whatever name suits.</p>\n<div class=\"gatsby-highlight\" data-language=\"sh\"><pre class=\"language-sh\"><code class=\"language-sh\">process fastqc_run {\n    publishDir &quot;$params.outdir/fastqc/$sample_id/&quot;, mode: &#39;copy&#39;\n    container &#39;biocontainers/fastqc:v0.11.9_cv8&#39;\n    cpus 16\n\n    input:\n    tuple val(sample_id), file(reads_file) from fastqc_reads\n\n    output:\n    file &quot;*_fastqc.{zip,html}&quot;\n\n    script:\n    &quot;&quot;&quot;\n    fastqc $reads_file -o . --threads ${task.cpus}\n    &quot;&quot;&quot;\n}</code></pre></div>\n<p>In general, there are 4 components to each process:</p>\n<ol>\n<li>A configuration block</li>\n<li>Process inputs</li>\n<li>Process outputs</li>\n<li>Script that runs the desired program</li>\n</ol>\n<p>Let’s break down the above process codeblock into the 4 components.</p>\n<h4 id=\"configuration\" style=\"position:relative;\"><a href=\"#configuration\" aria-label=\"configuration permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Configuration</h4>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">  publishDir \"$params.outdir/fastqc/$sample_id/\", mode: 'copy'\n  container 'biocontainers/fastqc:v0.11.9_cv8'\n  cpus 16</code></pre></div>\n<p><code class=\"language-text\">publishDir</code> This allows you to copy the output files of this process to a desired location for easy access. Note that by default it creates a shortcut link to the actual file location and you have to explicitly specify for it to copy and give you the actual file.</p>\n<p><code class=\"language-text\">container</code> <strong>This is where the real magic happens.</strong> If you specify a publicly available Docker container, Nextflow will seamlessly pull the container in, run the script and generate the output that you’re looking for. *side note on the config you will need to specify docker enabled as true.</p>\n<p><code class=\"language-text\">cpus</code> This specifies the amount of CPUs you wish to run for this process. You can also specify memory options and will help in autoscaling your cloud computation needs. In general this option is useful if you are using VMs of varying size and works quite well with Google Cloud.</p>\n<h4 id=\"inputs\" style=\"position:relative;\"><a href=\"#inputs\" aria-label=\"inputs permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Inputs</h4>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">  input:\n  tuple val(sample_id), file(reads_file) from fastqc_reads</code></pre></div>\n<p>The <code class=\"language-text\">Channel.fromFilePairs</code> method generates a tuple <code class=\"language-text\">[wildcard value, [the pair of files for processing]]</code>. Read <a href=\"https://www.nextflow.io/docs/latest/channel.html#fromfilepairs\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">here</a> for full documentation.</p>\n<p>So when we call it into the input, we assign the variable name <code class=\"language-text\">sample_id</code> to the wildcard value and call the files <code class=\"language-text\">reads_file</code>. As a side note, if you need to access the first file you can call <code class=\"language-text\">reads_file[0]</code> to do so and the second file is <code class=\"language-text\">reads_file[1]</code>.</p>\n<h4 id=\"outputs\" style=\"position:relative;\"><a href=\"#outputs\" aria-label=\"outputs permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Outputs</h4>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">  output:\n  file \"*_fastqc.{zip,html}\"</code></pre></div>\n<p>Here we are telling nextflow to expect a zip file and a html file from the output of fastqc. Since we declared <code class=\"language-text\">publishDir</code> above, nextflow will then copy these files to the report directory.</p>\n<h4 id=\"script\" style=\"position:relative;\"><a href=\"#script\" aria-label=\"script permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Script</h4>\n<p>Finally, let’s tell nextflow how to run fastqc!</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">  script:\n  \"\"\"\n  fastqc $reads_file -o . --threads ${task.cpus}\n  \"\"\"</code></pre></div>\n<p>A couple of comments. <code class=\"language-text\">-o .</code> tells fastqc to place the output in the current working directory - this will be located in nextflow’s work directory. <code class=\"language-text\">--threads ${task.cpus}</code> is how we parallelise fastqc to take advantage of the available cpus for this process.</p>\n<h3 id=\"4-here-is-how-the-pipeline-continues\" style=\"position:relative;\"><a href=\"#4-here-is-how-the-pipeline-continues\" aria-label=\"4 here is how the pipeline continues permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>4. Here is how the pipeline continues</h3>\n<p>The code below is hopefully pretty straightforward. The output from bowtie2 is split into two channels <code class=\"language-text\">aligned_ch</code> and <code class=\"language-text\">stats_ch</code>. <code class=\"language-text\">stat_ch</code> is sent to samtools to run flagstat and <code class=\"language-text\">aligned_ch</code> continues on for onward processing in the next steps of the pipeline.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">process bowtie2 {\n    container 'biocontainers/bowtie2:v2.4.1_cv1'\n    cpus 16\n\n    input:\n    tuple val(sample_id), file(reads_file) from reads_for_alignment\n    file db from bowtie2_db_ch\n\n    output:\n    tuple val(sample_id), file('*.sam') into aligned_ch, stats_ch\n\n    script:\n    \"\"\"\n    tar -xvf $db\n    bowtie2 -t -p ${task.cpus} -x bowtie2/GRCh38_bowtie2 -1 ${reads_file[0]} -2 ${reads_file[1]} -S ${sample_id}.sam\n    \"\"\"\n}\n\nprocess samtools_flagstat {\n    publishDir \"$params.outdir/samtools_flagstat/\"\n    container 'biocontainers/samtools:v1.9-4-deb_cv1'\n    cpus 16\n    tag \"$sample_id\"\n\n    input:\n    tuple val(sample_id), file(sam_file) from stats_ch\n\n    output:\n    path \"${sample_id}_flagstat.txt\"\n\n    script:\n    \"\"\"\n    samtools flagstat -@ ${task.cpus} $sam_file > ${sample_id}_flagstat.txt\n    \"\"\"\n}</code></pre></div>\n<h2 id=\"summary\" style=\"position:relative;\"><a href=\"#summary\" aria-label=\"summary permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Summary</h2>\n<p>The above is a simple introduction to using nextflow to pull in containers and orchestrate a pipeline. It is well worth investing some time to automate your pipeline - write your code once and use it forever!</p>\n<p>More importantly, this is one step closer to creating your cloud genomics supercomputer. We will cover this next.</p>\n<p><em>Stay tuned for more articles where I will explore the technological shifts happening not just in tech but also health and biology</em></p>","fields":{"slug":"/posts/bioinformatics-pipeline-with-nextflow","tagSlugs":["/tag/bioinformatics/","/tag/docker/","/tag/snakemake/","/tag/nextflow/"]},"frontmatter":{"date":"2021-08-12","description":"Now that you know how to run bioinformatics software in Docker containers, it's time to connect them up.","tags":["Bioinformatics","Docker","Snakemake","Nextflow"],"title":"How to Create Your Bioinformatics Pipeline with Nextflow","socialImage":{"publicURL":"/static/7ac17c4f63611789bd96206229d988b0/pipeline.jpg"}}}},"pageContext":{"slug":"/posts/bioinformatics-pipeline-with-nextflow"}},"staticQueryHashes":["251939775","401334301","825871152"]}